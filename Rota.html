<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Workforce | Solura</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --danger-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #34495e;
            --boh-color: #fffacd;
            --foh-color: #add8e6;
            --manager-color: #ffc0cb;
            --supervisor-color: #ffcc99;
            --holiday-color: #90ee90;
            --ion-safe-area-top: 20px;
            --ion-safe-area-bottom: 20px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
/* Date input styling */
input[type="date"] {
    padding: 10px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 14px;
    color: var(--dark-color);
    background-color: white;
    transition: all 0.3s ease;
    margin: 0 10px;
    cursor: pointer;
}

/* Focus state */
input[type="date"]:focus {
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
    outline: none;
}

/* Hover state */
input[type="date"]:hover {
    border-color: #bbb;
}

/* Calendar icon styling (works in most modern browsers) */
input[type="date"]::-webkit-calendar-picker-indicator {
    color: var(--primary-color);
    opacity: 1;
    font-size: 16px;
    padding: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
}

input[type="date"]::-webkit-calendar-picker-indicator:hover {
    opacity: 0.8;
    transform: scale(1.1);
}

/* For Firefox */
input[type="date"]::-moz-calendar-picker-indicator {
    filter: invert(0.5) sepia(1) saturate(5) hue-rotate(175deg);
    padding: 4px;
    cursor: pointer;
}

/* Disabled state */
input[type="date"]:disabled {
    background-color: #f5f5f5;
    color: #999;
    cursor: not-allowed;
}
/* Holiday Tab Styles */
#holiday-tab {
    padding: 20px;
}

.holiday-form {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 15px;
    margin-bottom: 20px;
    background: #f8f9fa;
    padding: 15px;
    border-radius: 5px;
}

.form-group {
    margin-bottom: 0;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
}

#daysCalculated {
    font-size: 1.2em;
    font-weight: bold;
    padding: 5px;
    background: #e9ecef;
    border-radius: 3px;
}

#holidayTable {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}

#holidayTable th, #holidayTable td {
    border: 1px solid #dee2e6;
    padding: 8px;
    text-align: center;
}

#holidayTable th {
    background-color: #343a40;
    color: white;
}

#holidayTable tr:nth-child(even) {
    background-color: #f2f2f2;
}

.holiday-cell {
    background-color: #90ee90 !important;
    position: relative;
}

.holiday-cell::after {
    content: "Holiday";
    position: absolute;
    bottom: 2px;
    right: 2px;
    font-size: 9px;
    color: darkgreen;
    font-weight: bold;
}
select, input[type="date"], input[type="time"] {
            padding: 0.5rem;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 1rem;
            transition: border-color 0.3s, box-shadow 0.3s;
        }

        select:focus, input[type="date"]:focus, input[type="time"]:focus {
            outline: none;
            border-color: var(--light-blue);
            box-shadow: 0 0 0 0.2rem rgba(0, 116, 217, 0.25);
        }
/* Readonly state */
input[type="date"]:read-only {
    background-color: #f9f9f9;
}
        body {
            background: #f5f7fa;
            color: #333;

            line-height: 1.6;
            width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  touch-action: manipulation;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
        }

        /* Navigation */
        .navbar {
            background-color: var(--secondary-color);
            color: white;
            padding: 15px 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .navbar-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 2900px;
            margin: 0 auto;
            padding: 0 20px;
        }
        /* Footer */
        footer {
            background-color: var(--navy-blue);
            color: var(--white);
            text-align: center;
        }
        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
        }
        .navbar-brand {
            font-size: 1.5rem;
            font-weight: bold;
            color: white;
            text-decoration: none;
        }

        .navbar-nav {
            display: flex;
            list-style: none;
        }

        .nav-item {
            margin-left: 20px;
        }

        .nav-link {
            color: white;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s;
        }

        .nav-link:hover {
            color: var(--primary-color);
        }

        .active {
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
        }

        /* Header */
        .header {
            text-align: center;
            margin: 30px 0;
            color: var(--secondary-color);
        }

        /* Tabs */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background: #f1f1f1;
            border: 1px solid #ddd;
            border-bottom: none;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
            transition: all 0.3s;
        }

        .tab.active {
            background: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
            font-weight: bold;
            color: var(--primary-color);
        }

        .tab:hover {
            background: #e9e9e9;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            background: white;
            border-radius: 8px;
        }

        th, td {
            padding: 12px 15px;
            text-align: center;
            border: 1px solid #e0e0e0;
        }

        th {
            background-color: var(--secondary-color);
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        tr:hover {
            background-color: #f1f1f1;
        }

        /* Buttons */
        .btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            margin: 5px;
            text-transform: uppercase;
        }

        .btn:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .btn-secondary {
            background-color: var(--secondary-color);
        }

        .btn-success {
            background-color: var(--success-color);
        }

        .btn-warning {
            background-color: var(--warning-color);
        }

        .btn-danger {
            background-color: var(--danger-color);
        }

        .btn-sm {
            padding: 5px 10px;
            font-size: 12px;
        }
/* Add to your stylesheet */
.tab-content {
    display: block !important; /* Remove inline display:none */
    opacity: 0;
    transition: opacity 0.3s ease;
    height: 0;

}

.tab-content.active {
    opacity: 1;
    height: auto;
}

#holiday-tab {
    padding: 20px;
}
        /* Time inputs */
        .time-input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            width: 90px;
            margin: 2px;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        .time-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
            outline: none;
        }

        /* Cell colors */
        .boh-row {
            background-color: var(--boh-color);
        }

        .foh-row {
            background-color: var(--foh-color);
        }

        .manager-row {
            background-color: var(--manager-color);
        }

        .supervisor-row {
            background-color: var(--supervisor-color);
        }

        .holiday-cell {
            background-color: var(--holiday-color);
        }

        /* Drag and drop */
        .draggable {
            cursor: move;
        }

        .dragging {
            opacity: 0.5;
            background-color: rgba(52, 152, 219, 0.2);
        }

        .dragover {
            background-color: rgba(46, 204, 113, 0.2);
            border: 2px dashed var(--success-color);
        }

        /* Popup messages */
        .popup {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 25px;
            border-radius: 5px;
            color: white;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            animation: slideIn 0.3s, fadeOut 0.5s 2.5s forwards;
        }

        .popup.success {
            background-color: var(--success-color);
        }

        .popup.error {
            background-color: var(--danger-color);
        }

        .popup.warning {
            background-color: var(--warning-color);
        }

        @keyframes slideIn {
            from { bottom: -50px; opacity: 0; }
            to { bottom: 20px; opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        .request-type-options {
    display: flex;
    gap: 20px;
    margin-top: 10px;
}

.radio-label {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
}

.radio-label input[type="radio"] {
    margin: 0;
}
        /* Forecast table */
        .forecast-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
        }
        .write-off-btn {
    background-color: var(--primary-color);
    color: white;
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 2px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}
.highlight-tab {
    background-color: #fff8e1 !important;
    transition: background-color 0.2s ease;
}
.write-off-btn:hover {
    background-color: #094d50; /* Slightly darker red */
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}
        /* Responsive */
        @media (max-width: 768px) {
            .navbar-container {
                flex-direction: column;
                padding: 10px;
            }

            .navbar-nav {
                margin-top: 15px;
                flex-wrap: wrap;
                justify-content: center;
            }

            .nav-item {
                margin: 5px 10px;
            }

            table {
                font-size: 14px;
            }

            th, td {
                padding: 8px 10px;
            }

            .time-input {
                width: 60px;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="navbar-container">
            <a href="Admin.html" class="navbar-brand">Solura Admin</a>
            <ul class="navbar-nav">
                <li class="nav-item"><a href="#" class="nav-link active" data-tab="rota-tab">Rota</a></li>
                <li class="nav-item"><a href="#" class="nav-link" data-tab="forecast-tab">Forecast</a></li>
                <li class="nav-item"><a href="#" class="nav-link" data-tab="holiday-tab">Holidays</a></li>
                <li class="nav-item"><a href="#" class="nav-link" data-tab="reports-tab">Reports</a></li>
            </ul>
        </div>
    </nav>

    <div class="container">
        <!-- Rota Tab -->
        <div id="rota-tab" class="tab-content active">
            <h1 class="header">Workforce Management</h1>
            
            <div class="controls">
                <button class="btn btn-secondary" onclick="copyFromPreviousWeek(); fetchAndPopulateRotaTable(); updateRotaWithHolidays()">
                    <i class="fas fa-copy"></i> Copy From Previous Week
                </button>
                <input type="date" id="weekStartDate" class="date" onchange="updateWeek(); fetchAndPopulateRotaTable(); updateRotaWithHolidays()">
                <button class="btn btn-success" onclick="saveRotaData();">
                    <i class="fas fa-save"></i> Save
                </button>
                <button class="btn btn-warning" onclick="clearAllRotaData();">
                    <i class="fas fa-trash-alt"></i> Clear All
                </button>
                <button class="btn btn-primary" onclick="submitRotaData();">
                    <i class="fas fa-paper-plane"></i> Publish
                </button>
            </div>

            <table id="hoursTable">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Last Name</th>
                        <th>Wage (£)</th>
                        <th>Role</th>
                        <th id="mondayHeader" data-day="monday">Monday</th>
                        <th id="tuesdayHeader" data-day="tuesday">Tuesday</th>
                        <th id="wednesdayHeader" data-day="wednesday">Wednesday</th>
                        <th id="thursdayHeader" data-day="thursday">Thursday</th>
                        <th id="fridayHeader" data-day="friday">Friday</th>
                        <th id="saturdayHeader" data-day="saturday">Saturday</th>
                        <th id="sundayHeader" data-day="sunday">Sunday</th>
                        <th>Total Hours</th>
                        <th>Total Spent (£)</th>
                    </tr>
                </thead>
                <tbody id="employeeRows">
                    <!-- Employee rows will be dynamically generated here -->
                </tbody>
                <tfoot>
                    <tr id="totalrow">
                        <td colspan="4">Weekly Totals</td>
                        <td class="day-total" data-day="monday"></td>
                        <td class="day-total" data-day="tuesday"></td>
                        <td class="day-total" data-day="wednesday"></td>
                        <td class="day-total" data-day="thursday"></td>
                        <td class="day-total" data-day="friday"></td>
                        <td class="day-total" data-day="saturday"></td>
                        <td class="day-total" data-day="sunday"></td>
                        <td id="weeklyHoursTotal"></td>
                        <td id="weeklySpentTotal"></td>
                    </tr>
                    <tr>
                        <td colspan="10"></td>
                        <td>Holiday Rate</td>
                        <td>
                            <input type="number" id="holidayPercentageInput" class="forecast-input" 
                                   onchange="saveHolidayPercentage(this.value), calculateHolidayPercentage()">%
                        </td>                
                        <td id="result-holiday"></td>
                    </tr>
                    <tr>
                        <td colspan="10"></td>
                        <td>Tax Rate</td>
                        <td>
                            <input type="number" id="taxPercentageInput" class="forecast-input" 
                                   onchange="saveTaxPercentage(this.value), calculateTaxPercentage()">%
                        </td>                
                        <td id="result-tax"></td>
                    </tr>
                    <tr>
                        <td colspan="10"></td>
                        <td>Pension Rate</td>
                        <td>
                            <input type="number" id="pensionPercentageInput" class="forecast-input" 
                                   onchange="savePensionPercentage(this.value), calculatePensionPercentage()">%
                        </td>                
                        <td id="result-pension"></td>
                    </tr>    
                    <tr>
                        <td colspan="11"></td>
                        <td><strong>Total Cost Week</strong></td>              
                        <td id="totalcostweek"><strong>£0.00</strong></td>
                    </tr>             
                </tfoot>
            </table>
        </div>

        <!-- Holiday Tab -->
        <div id="holiday-tab" class="tab-content" style="display:none;">
    <h1 class="header">Holiday Management</h1>
    
    <div class="controls">
        <div class="week-navigation">
            <button id="prevWeek" class="btn btn-secondary">
                <i class="fas fa-chevron-left"></i> Previous Week
            </button>
            <span id="weekDisplay" class="week-display"></span>
            <input type="date" id="weekSelector" class="form-control week-selector">
            <button id="nextWeek" class="btn btn-secondary">
                Next Week <i class="fas fa-chevron-right"></i>
            </button>
        </div>
    </div>
    
    <div class="holiday-form">
        <div class="form-group">
            <label for="employeeSelect"><i class="fas fa-user-plus"></i> Employee:</label>
            <select id="employeeSelect" class="employee-select">
                <option value="">Select Employee</option>
                <!-- Will be populated by JavaScript -->
            </select>
        </div>

        <div class="form-group">
            <label for="startDate">Start Date:</label>
            <input type="date" id="startDate" class="form-control">
        </div>

        <div class="form-group">
            <label for="endDate">End Date:</label>
            <input type="date" id="endDate" class="form-control">
        </div>

        <div class="form-group">
            <label>Request Type:</label>
            <div class="request-type-options">
                <label class="radio-label">
                    <input type="radio" name="requestType" value="holiday" checked> 
                    <i class="fas fa-umbrella-beach"></i> Holiday
                </label>
                <label class="radio-label">
                    <input type="radio" name="requestType" value="unpaid"> 
                    <i class="fas fa-money-bill-wave"></i> Unpaid Leave
                </label>
            </div>
        </div>

        <div class="form-group">
            <label>Days Requested:</label>
            <div id="daysCalculated">0</div>
        </div>
        
        <button class="btn btn-success" onclick="submitHolidayRequest()">
            <i class="fas fa-paper-plane"></i> Save
        </button>
    </div>
    
    <div class="holiday-table-container">
        <table id="holidayTable" class="holiday-table">
            <thead>
                <tr>
                    <th>Employee</th>
                    <th class="day-header">Monday</th>
                    <th class="day-header">Tuesday</th>
                    <th class="day-header">Wednesday</th>
                    <th class="day-header">Thursday</th>
                    <th class="day-header">Friday</th>
                    <th class="day-header">Saturday</th>
                    <th class="day-header">Sunday</th>
                </tr>
            </thead>
            <tbody>
                <!-- Will be populated by JavaScript -->
            </tbody>
        </table>
    </div>
        </div>

        <!-- Forecast Tab -->
        <div id="forecast-tab" class="tab-content">
            <h1 class="header">Weekly Sales Forecast</h1>
            
            <div class="controls">
                <input type="date" id="forecastWeekStart" class="date" onchange="updateForecastWeek()">
                <button class="btn btn-success" onclick="saveForecastData()">
                    <i class="fas fa-save"></i> Save Forecast
                </button>
            </div>

            <table id="forecastTable">
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th id="forecastMonday">Monday</th>
                        <th id="forecastTuesday">Tuesday</th>
                        <th id="forecastWednesday">Wednesday</th>
                        <th id="forecastThursday">Thursday</th>
                        <th id="forecastFriday">Friday</th>
                        <th id="forecastSaturday">Saturday</th>
                        <th id="forecastSunday">Sunday</th>
                        <th>Weekly Total</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Expected Customers</td>
                        <td><input type="number" class="forecast-input" data-day="monday" data-metric="customers"></td>
                        <td><input type="number" class="forecast-input" data-day="tuesday" data-metric="customers"></td>
                        <td><input type="number" class="forecast-input" data-day="wednesday" data-metric="customers"></td>
                        <td><input type="number" class="forecast-input" data-day="thursday" data-metric="customers"></td>
                        <td><input type="number" class="forecast-input" data-day="friday" data-metric="customers"></td>
                        <td><input type="number" class="forecast-input" data-day="saturday" data-metric="customers"></td>
                        <td><input type="number" class="forecast-input" data-day="sunday" data-metric="customers"></td>
                        <td id="totalCustomers">0</td>
                    </tr>
                    <tr>
                        <td>Expected Sales (£)</td>
                        <td><input type="number" class="forecast-input" data-day="monday" data-metric="sales"></td>
                        <td><input type="number" class="forecast-input" data-day="tuesday" data-metric="sales"></td>
                        <td><input type="number" class="forecast-input" data-day="wednesday" data-metric="sales"></td>
                        <td><input type="number" class="forecast-input" data-day="thursday" data-metric="sales"></td>
                        <td><input type="number" class="forecast-input" data-day="friday" data-metric="sales"></td>
                        <td><input type="number" class="forecast-input" data-day="saturday" data-metric="sales"></td>
                        <td><input type="number" class="forecast-input" data-day="sunday" data-metric="sales"></td>
                        <td id="totalSales">£0.00</td>
                    </tr>
                    <tr>
                        <td>Labor Cost (£)</td>
                        <td><input type="number" class="forecast-input" data-day="monday" data-metric="labor"></td>
                        <td><input type="number" class="forecast-input" data-day="tuesday" data-metric="labor"></td>
                        <td><input type="number" class="forecast-input" data-day="wednesday" data-metric="labor"></td>
                        <td><input type="number" class="forecast-input" data-day="thursday" data-metric="labor"></td>
                        <td><input type="number" class="forecast-input" data-day="friday" data-metric="labor"></td>
                        <td><input type="number" class="forecast-input" data-day="saturday" data-metric="labor"></td>
                        <td><input type="number" class="forecast-input" data-day="sunday" data-metric="labor"></td>
                        <td id="totalLabor">£0.00</td>
                    </tr>
                    <tr>
                        <td>Labor %</td>
                        <td id="laborPercentMonday">0%</td>
                        <td id="laborPercentTuesday">0%</td>
                        <td id="laborPercentWednesday">0%</td>
                        <td id="laborPercentThursday">0%</td>
                        <td id="laborPercentFriday">0%</td>
                        <td id="laborPercentSaturday">0%</td>
                        <td id="laborPercentSunday">0%</td>
                        <td id="totalLaborPercent">0%</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Reports Tab -->
        <div id="reports-tab" class="tab-content">
            <h1 class="header">Reports</h1>
            <p>Reports functionality will be implemented here.</p>
        </div>
    </div>

    <div id="popupMessage" class="popup" style="display: none;"></div>
    <footer>
        <div class="footer-content">
            <p>&copy; Solura Ltd 2024, All rights reserved</p>
        </div>
    </footer>
    <script>
// Function to update labor inputs from day totals
function updateLaborInputsFromDayTotals() {
    // Get all day-total cells
    const dayTotalCells = document.querySelectorAll('.day-total[data-day]');
    
    dayTotalCells.forEach(cell => {
        const day = cell.dataset.day;
        // Extract £ value from complex string (handles "35.00h / £418.50" format)
        const content = cell.textContent.trim();
        const poundValueMatch = content.match(/£(\d+\.?\d*)/);
        const value = poundValueMatch ? parseFloat(poundValueMatch[1]) : 0;
        
        // Find corresponding labor input
        const laborInput = document.querySelector(`input[data-day="${day}"][data-metric="labor"]`);
        if (laborInput) {
            laborInput.value = value;
        }
    });
    updateForecastTotals();
}
// Tab Key Listener
document.addEventListener('keydown', function(event) {
    if (event.key === 'Tab') {
        const activeElement = document.activeElement;
        
        // Only handle inputs in the forecast table
        if (activeElement.tagName === 'INPUT' && activeElement.closest('#forecastTable')) {
            event.preventDefault(); // Always prevent default tab behavior
            
            const table = document.getElementById('forecastTable');
            const inputs = Array.from(table.querySelectorAll('input[type="number"]'));
            const currentIndex = inputs.indexOf(activeElement);
            
            if (currentIndex !== -1) {
                // Calculate next index (move to same day in next metric row)
                const daysInWeek = 7; // Monday through Sunday columns
                const metricsCount = 3; // Customers, Sales, Labor rows
                const nextIndex = currentIndex + daysInWeek;
                
                if (nextIndex < inputs.length) {
                    // Move to same day in next metric row
                    const nextInput = inputs[nextIndex];
                    nextInput.value = ''; // Clear the input
                    nextInput.focus();
                    nextInput.select();
                } else {
                    // If at last row, move to next day's first metric
                    const currentDayIndex = currentIndex % daysInWeek;
                    const nextDayIndex = currentDayIndex + 1;
                    
                    if (nextDayIndex < daysInWeek) {
                        // Move to next day's first metric (Customers)
                        const nextDayInput = inputs[nextDayIndex];
                        nextDayInput.value = '';
                        nextDayInput.focus();
                        nextDayInput.select();
                    } else {
                        // If at Sunday, wrap to Monday's first metric
                        inputs[0].value = '';
                        inputs[0].focus();
                        inputs[0].select();
                    }
                }
                
                // Visual feedback
                const nextInput = document.activeElement;
                nextInput.classList.add('highlight-tab');
                setTimeout(() => {
                    nextInput.classList.remove('highlight-tab');
                }, 200);
            }
        }
    }
});
// Global variables
let currentDraggedCell = null;
// Initialize the application when the DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
            // Set up tab navigation
            setupTabs();
            
            // Initialize the rota
            fetchEmployeeData();
            displayCurrentWeek();
            
            // Load saved percentages
            loadHolidayPercentage();
            loadTaxPercentage();
            loadPensionPercentage();
            
            // Initialize the forecast
            updateForecastWeek();
            setupForecastInputs();
            
            // Set today's date as default for both rota and forecast
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('weekStartDate').value = today;
            document.getElementById('forecastWeekStart').value = today;
        });
// Tab navigation setup
function setupTabs() {
            const tabs = document.querySelectorAll('[data-tab]');
            tabs.forEach(tab => {
                tab.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Remove active class from all tabs and content
                    document.querySelectorAll('.nav-link').forEach(link => link.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding content
                    this.classList.add('active');
                    const tabId = this.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');
                });
            });
        }
// Modified Forecast functions with auto-loading current week
document.addEventListener('DOMContentLoaded', function() {
    // Set initial week to current week when page loads
    initializeForecastWeek();
});
// Function to Initialize Forecast Week
function initializeForecastWeek() {
    const today = new Date();
    const monday = getMonday(today);
    
    // Format date for input field (YYYY-MM-DD)
    const formattedDate = formatDateForInput(monday);
    document.getElementById('forecastWeekStart').value = formattedDate;
    
    // Update the week display
    updateForecastWeek();
}
// Helper Function
function formatDateForInput(date) {
    if (!(date instanceof Date) || isNaN(date)) {
        console.error('Invalid date provided to formatDateForInput');
        return '';
    }
    
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0'); // Months are 0-indexed
    const day = String(date.getDate()).padStart(2, '0');
    
    return `${year}-${month}-${day}`;
}
// Helper Function
function updateForecastWeek() {
    const forecastWeekStart = document.getElementById('forecastWeekStart').value;
    const date = new Date(forecastWeekStart);
    
    if (!isNaN(date)) {
        const monday = getMonday(date);
        const weekDates = getWeekDates(monday);
        
        // Update forecast table headers
        updateForecastHeaders(weekDates);
        
        // Load forecast data for this week
        loadForecastData(weekDates);
    }
}
// Helper Function
function updateForecastHeaders(weekDates) {
    const daysOfWeek = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
    
    daysOfWeek.forEach((day, index) => {
        const header = document.getElementById(`forecast${day}`);
        if (header) {
            const formattedDate = formatDate(weekDates[index]);
            header.textContent = `${formattedDate} (${day})`;
            header.dataset.date = formattedDate;
            header.dataset.dayName = day; // Store day name for reference
        }
    });
}
// Helper Function
function setupForecastInputs() {
            const inputs = document.querySelectorAll('#forecastTable input');
            inputs.forEach(input => {
                input.addEventListener('input', updateForecastTotals);
            });
        }
// Helper Function
function updateForecastTotals() {
            // Calculate totals for customers
            const customerInputs = document.querySelectorAll('input[data-metric="customers"]');
            let totalCustomers = 0;
            customerInputs.forEach(input => {
                totalCustomers += parseInt(input.value) || 0;
            });
            document.getElementById('totalCustomers').textContent = totalCustomers;
            
            // Calculate totals for sales
            const salesInputs = document.querySelectorAll('input[data-metric="sales"]');
            let totalSales = 0;
            salesInputs.forEach(input => {
                totalSales += parseFloat(input.value) || 0;
            });
            document.getElementById('totalSales').textContent = `£${totalSales.toFixed(2)}`;
            
            // Calculate totals for labor
            const laborInputs = document.querySelectorAll('input[data-metric="labor"]');
            let totalLabor = 0;
            laborInputs.forEach(input => {
                totalLabor += parseFloat(input.value) || 0;
            });
            document.getElementById('totalLabor').textContent = `£${totalLabor.toFixed(2)}`;
            
            // Calculate labor percentages
            for (let i = 0; i < 7; i++) {
                const daySales = parseFloat(salesInputs[i].value) || 1; // Avoid division by zero
                const dayLabor = parseFloat(laborInputs[i].value) || 0;
                const laborPercent = (dayLabor / daySales) * 100;
                
                const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                document.getElementById(`laborPercent${dayNames[i]}`).textContent = `${laborPercent.toFixed(1)}%`;
            }
            
            // Calculate total labor percentage
            const totalLaborPercent = (totalLabor / (totalSales || 1)) * 100;
            document.getElementById('totalLaborPercent').textContent = `${totalLaborPercent.toFixed(1)}%`;
        }
// Helper Function
async function loadForecastData(weekDates) {
    try {
        const formattedDates = weekDates.map(date => formatDateWithDay(date));
        const response = await fetch(`/rota/forecast/get?dates=${formattedDates.join(',')}`);
        
        if (response.ok) {
            const result = await response.json();
            
            // Check if we got successful response with data
            if (result.success && result.data) {
                // Populate the forecast inputs with the retrieved data
                result.data.forEach(dayData => {
                    const dayOfWeek = getWeekdayFromDate(dayData.day);
                    if (dayOfWeek) {
                        const dayLower = dayOfWeek.toLowerCase();
                        
                        // Set values only if they exist in the response
                        const customersInput = document.querySelector(`input[data-day="${dayLower}"][data-metric="customers"]`);
                        const salesInput = document.querySelector(`input[data-day="${dayLower}"][data-metric="sales"]`);
                        const laborInput = document.querySelector(`input[data-day="${dayLower}"][data-metric="labor"]`);
                        
                        if (customersInput) customersInput.value = dayData.customers !== undefined ? dayData.customers : '';
                        if (salesInput) salesInput.value = dayData.sales !== undefined ? dayData.sales : '';
                        if (laborInput) laborInput.value = dayData.labor !== undefined ? dayData.labor : '';
                    }
                });
                
                updateForecastTotals();
            }
        } else {
            console.error('Failed to load forecast data:', response.status);
            // Initialize empty values if no data exists
            initializeEmptyForecast();
        }
    } catch (error) {
        console.error('Error loading forecast data:', error);
        initializeEmptyForecast();
    }
}
// Helper function to initialize empty forecast inputs
function initializeEmptyForecast() {
    const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    days.forEach(day => {
        document.querySelector(`input[data-day="${day}"][data-metric="customers"]`).value = '';
        document.querySelector(`input[data-day="${day}"][data-metric="sales"]`).value = '';
        document.querySelector(`input[data-day="${day}"][data-metric="labor"]`).value = '';
    });
    updateForecastTotals();
}
// Function to Save and send Forecast Data
async function saveForecastData() {
            const weekStartDate = document.getElementById('forecastWeekStart').value;
            const date = new Date(weekStartDate);
            
            if (isNaN(date)) {
                showPopup('Invalid date selected', 'error');
                return;
            }
            
            const monday = getMonday(date);
            const weekDates = getWeekDates(monday);
            const forecastData = [];
            
            // Collect forecast data from inputs
            const daysOfWeek = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
            daysOfWeek.forEach((day, index) => {
                const formattedDate = formatDateWithDay(weekDates[index]);
                
                forecastData.push({
                    day: formattedDate,
                    customers: parseInt(document.querySelector(`input[data-day="${day}"][data-metric="customers"]`).value) || 0,
                    sales: parseFloat(document.querySelector(`input[data-day="${day}"][data-metric="sales"]`).value) || 0,
                    labor: parseFloat(document.querySelector(`input[data-day="${day}"][data-metric="labor"]`).value) || 0
                });
            });
            
            try {
                const response = await fetch('/rota/forecast/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(forecastData),
                });
                
                if (response.ok) {
                    showPopup('Forecast saved successfully', 'success');
                } else {
                    throw new Error('Failed to save forecast');
                }
            } catch (error) {
                console.error('Error saving forecast:', error);
                showPopup('Error saving forecast', 'error');
            }
        }
// Helper function to show popup messages
function showPopup(message, type = 'success') {
            const popup = document.getElementById('popupMessage');
            popup.textContent = message;
            popup.className = `popup ${type}`;
            popup.style.display = 'block';
            
            setTimeout(() => {
                popup.style.display = 'none';
            }, 3000);
        }
// Function to Copy Entire Previous Week's Rota
async function copyFromPreviousWeek() {
    // Get the current and previous week dates
    const currentWeekStart = getSelectedWeekStart();
    const currentWeekFormatted = formatDateWithDay(currentWeekStart);
    
    const prevWeekStart = new Date(currentWeekStart);
    prevWeekStart.setDate(prevWeekStart.getDate() - 7);
    const prevWeekFormatted = formatDateWithDay(prevWeekStart);

    // Show loading state
    showLoading('Loading previous week\'s rota...');

    try {
        // 1. First fetch the previous week's data for all days
        const fetchResponse = await fetch(`/rota/get-previous-week-rota?prevWeek=${encodeURIComponent(prevWeekFormatted)}`);
        const fetchData = await fetchResponse.json();

        if (!fetchData.success) {
            throw new Error(fetchData.message || 'Failed to fetch previous week data');
        }

        if (fetchData.data.length === 0) {
            showPopup('No data found for previous week', 'warning');
            return;
        }

        // 2. Transform the data to match exact column names and update dates
        const transformedData = fetchData.data.map(entry => {
            // Extract the day name (Monday, Tuesday, etc.)
            const dayName = entry.day.match(/\(([^)]+)\)/)[1];
            
            // Calculate the corresponding date in the current week
            const currentWeekDay = new Date(currentWeekStart);
            const dayOffset = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
                .indexOf(dayName);
            
            currentWeekDay.setDate(currentWeekStart.getDate() + dayOffset);
            
            // Format the new date with day name (dd/mm/yyyy (Dayname))
            const formattedDate = formatDate(currentWeekDay);
            const newDay = `${formattedDate} (${dayName})`;

            return {
                name: entry.name,
                lastName: entry.lastName,
                wage: entry.wage,
                designation: entry.designation,
                day: newDay, // Updated to current week's date
                startTime: entry.startTime,
                endTime: entry.endTime,
                color: entry.color
            };
        });

        // 3. Then send the properly mapped data to be inserted
        const insertResponse = await fetch('/rota/insert-copied-rota', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                currentWeek: currentWeekFormatted,
                rotaData: transformedData
            })
        });
        
        const insertResult = await insertResponse.json();

        if (!insertResult.success) {
            throw new Error(insertResult.message || 'Failed to insert copied data');
        }

        // 4. Refresh the table to show the new data
        await fetchAndPopulateRotaTable();
        showPopup('Previous week\'s rota copied successfully!', 'success');
        
    } catch (error) {
        console.error('Error copying previous week:', error);
        showPopup(`Error: ${error.message}`, 'error');
    } finally {
        hideLoading();
    }
}
// Helper functions
function showLoading(message) {
    const loadingElement = document.getElementById('loadingIndicator');
    if (loadingElement) {
        loadingElement.textContent = message;
        loadingElement.style.display = 'block';
    }
}
// Improved drag and drop functionality with copy behavior
function handleDragStart(event) {
    currentDraggedCell = event.target.closest('td');
    if (currentDraggedCell && currentDraggedCell.hasAttribute('data-day')) {
        event.dataTransfer.setData('text/plain', currentDraggedCell.getAttribute('data-day'));
        currentDraggedCell.classList.add('dragging');
        
        // Store all shift data including times
        const row = currentDraggedCell.closest('tr');
        const name = row.children[0].textContent.trim();
        const lastName = row.children[1].textContent.trim();
        const day = currentDraggedCell.getAttribute('data-day');
        
        // Extract all time values from the source cell
        const timeInputs = currentDraggedCell.querySelectorAll('input[type="time"]');
        const timeSlots = Array.from(timeInputs).map(input => input.value);
        
        event.dataTransfer.setData('application/json', JSON.stringify({
            name,
            lastName,
            day,
            timeSlots, // Store all time values [start1, end1, start2, end2]
            backgroundColor: currentDraggedCell.style.backgroundColor,
            isOff: currentDraggedCell.querySelector('.write-off-btn.off') !== null
        }));
    }
}
// Helper Function
function handleDragOver(event) {
    event.preventDefault();
    const targetCell = event.target.closest('td');
    
    if (targetCell && targetCell.hasAttribute('data-day') && targetCell !== currentDraggedCell) {
        // Highlight potential drop target
        document.querySelectorAll('.dragover').forEach(cell => cell.classList.remove('dragover'));
        targetCell.classList.add('dragover');
    }
}
// Helper Function
function handleDragEnd() {
    document.querySelectorAll('.dragging, .dragover').forEach(el => {
        el.classList.remove('dragging', 'dragover');
    });
    currentDraggedCell = null;
}
// Helper Function
async function handleDrop(event) {
    event.preventDefault();
    const targetCell = event.target.closest('td');
    
    if (!targetCell || !targetCell.hasAttribute('data-day') || targetCell === currentDraggedCell) {
        return;
    }
    
    try {
        const data = JSON.parse(event.dataTransfer.getData('application/json'));
        const targetDay = targetCell.getAttribute('data-day');
        
        // Get the employee row for the target cell
        const targetRow = targetCell.closest('tr');
        const targetName = targetRow.children[0].textContent.trim();
        const targetLastName = targetRow.children[1].textContent.trim();
        
        // Get the week dates
        const weekStartDate = document.getElementById('weekStartDate').value;
        const date = new Date(weekStartDate);
        const monday = getMonday(date);
        const weekDates = getWeekDates(monday);
        
        // Get formatted dates
        const dayIndexMap = {
            monday: 0, tuesday: 1, wednesday: 2, thursday: 3,
            friday: 4, saturday: 5, sunday: 6
        };
        
        const sourceDate = formatDateWithDay(weekDates[dayIndexMap[data.day]]);
        const targetDate = formatDateWithDay(weekDates[dayIndexMap[targetDay]]);
        
        // Copy the shift data to target cell (don't clear source cell)
        if (data.isOff) {
            // If source was "Off", set target to "Off"
            const offButton = targetCell.querySelector('.write-off-btn');
            if (offButton) {
                offButton.click(); // Toggle to Off state
            }
        } else {
            // Copy time slots to target cell
            const timeInputs = targetCell.querySelectorAll('input[type="time"]');
            data.timeSlots.forEach((time, index) => {
                if (timeInputs[index]) {
                    timeInputs[index].value = time;
                }
            });
            
            // Copy background color
            targetCell.style.backgroundColor = data.backgroundColor;
            
            // Ensure time inputs are visible
            timeInputs.forEach(input => input.style.display = '');
        }
        
        // Save the new shift to database (without deleting source)
        await saveCopiedShift(
            data.name, data.lastName, sourceDate,
            targetName, targetLastName, targetDate,
            data.timeSlots, data.backgroundColor
        );
        
        // Update totals for both rows
        if (currentDraggedCell) {
            updateTotalHoursForRow(currentDraggedCell.closest('tr'));
        }


        
        showPopup('Shift copied successfully', 'success');
    } catch (error) {
        console.error('Error handling drop:', error);
        showPopup('Error copying shift', 'error');
    } finally {
        handleDragEnd();
    }
}
// Helper Function
async function saveCopiedShift(sourceName, sourceLastName, sourceDate, 
                             targetName, targetLastName, targetDate,
                             timeSlots, backgroundColor) {
    try {
        const response = await fetch('/rota/copyShift', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                sourceName,
                sourceLastName,
                sourceDate,
                targetName,
                targetLastName,
                targetDate,
                timeSlots, // [start1, end1, start2, end2]
                backgroundColor
            }),
        });
        
        if (!response.ok) {
            throw new Error('Failed to save copied shift');
        }
    } catch (error) {
        console.error('Error saving copied shift:', error);
        throw error;
    }
}
// Helper functions
function hideLoading() {
    const loadingElement = document.getElementById('loadingIndicator');
    if (loadingElement) {
        loadingElement.style.display = 'none';
    }
}
// Helper functions
function showPopup(message, type = 'success') {
    const popup = document.getElementById('popupMessage');
    popup.textContent = message;
    popup.className = `popup ${type}`;
    popup.style.display = 'block';
    
    setTimeout(() => {
        popup.style.display = 'none';
    }, 3000);
}
// Shows a popup message
function showPopup(message, type = 'success') {
    const popup = document.getElementById('popupMessage');
    popup.textContent = message;
    popup.style.backgroundColor = type === 'success' ? '#27ae60' : '#e74c3c';
    popup.classList.add('show');
    
    setTimeout(() => {
        popup.classList.remove('show');
    }, 3000);
}
// Save holiday percentage dynamically when the value changes
async function saveHolidayPercentage(percentage) {
    if (percentage === "" || percentage < 0 || percentage > 100) {
        alert('Please enter a valid percentage between 0 and 100.');
        return;
    }

    try {
        const response = await fetch('/rota/save-holiday-percentage', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ holiday: percentage }),
        });

        if (response.ok) {
        } else {
            console.error('Failed to save holiday percentage.');
        }
    } catch (error) {
        console.error('Error saving holiday percentage:', error);
    }
}
// Load saved holiday percentage when the page loads
async function loadHolidayPercentage() {
    try {
        const response = await fetch('/rota/get-holiday-percentage');
        if (response.ok) {
            const data = await response.json();
            const inputField = document.getElementById('holidayPercentageInput');
            inputField.value = data.holiday || ''; // Set the saved value
        } else {
            console.error('Failed to load holiday percentage.');
        }
    } catch (error) {
        console.error('Error loading holiday percentage:', error);
    }
}
// Save Tax percentage dynamically when the value changes
async function saveTaxPercentage(percentage) {
    if (percentage === "" || percentage < 0 || percentage > 100) {
        alert('Please enter a valid percentage between 0 and 100.');
        return;
    }
    try {
        const response = await fetch('/rota/save-tax-percentage', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ tax: percentage }),
        });
    } catch (error) {
        console.error('Error saving tax percentage:', error);
    }
}
// Load saved tax percentage when the page loads
async function loadTaxPercentage() {
    try {
        const response = await fetch('/rota/get-tax-percentage');
        if (response.ok) {
            const data = await response.json();
            const inputField = document.getElementById('taxPercentageInput');
            inputField.value = data.tax || ''; // Set the saved value
        } else {
            console.error('Failed to load tax percentage.');
        }
    } catch (error) {
        console.error('Error loading tax percentage:', error);
    }
}
// Save Pension percentage dynamically when the value changes
async function savePensionPercentage(percentage) {
    if (percentage === "" || percentage < 0 || percentage > 100) {
        alert('Please enter a valid percentage between 0 and 100.');
        return;
    }
    try {
        const response = await fetch('/rota/save-pension-percentage', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ pension: percentage }),
        });
    } catch (error) {
        console.error('Error saving pension percentage:', error);
    }
}
// Load saved pension percentage when the page loads
async function loadPensionPercentage() {
    try {
        const response = await fetch('/rota/get-pension-percentage');
        if (response.ok) {
            const data = await response.json();
            const inputField = document.getElementById('pensionPercentageInput');
            inputField.value = data.pension || ''; // Set the saved value
        } else {
            console.error('Failed to load pension percentage.');
        }
    } catch (error) {
        console.error('Error loading pension percentage:', error);
    }
}
// Function to display current week
function displayCurrentWeek() {
    // Get the current date
    const currentDate = new Date();

    // Get the current day of the week (0 = Sunday, 1 = Monday, ..., 6 = Saturday)
    const dayOfWeek = currentDate.getDay();

    // Calculate the difference between the current date and the last Monday (start of the week)
    const diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;

    // Get the current week's start (Monday) date
    const startOfWeek = new Date(currentDate);
    startOfWeek.setDate(currentDate.getDate() + diffToMonday);

    // Create an array to hold the dates for the current week (Monday to Sunday)
    const weekDates = [];

    for (let i = 0; i < 7; i++) {
        const currentDay = new Date(startOfWeek);
        currentDay.setDate(startOfWeek.getDate() + i);

        // Format the date as dd/mm/yyyy (Day)
        const day = String(currentDay.getDate()).padStart(2, '0');
        const month = String(currentDay.getMonth() + 1).padStart(2, '0'); // Months are zero-based
        const year = currentDay.getFullYear();
        const weekday = currentDay.toLocaleDateString('en-GB', { weekday: 'long' }); // Get long weekday name

        const formattedDate = `${day}/${month}/${year} (${weekday})`;
        weekDates.push(formattedDate);
    }

    // Display the week dates in the table headers
    const headers = document.querySelectorAll('[data-day]');
    headers.forEach((header, index) => {
        header.textContent = weekDates[index];
    });
} 
// Function to update the table based on selected week
function updateWeek() {
    const weekStartDate = document.getElementById('weekStartDate').value;
    const date = new Date(weekStartDate);
    
    // Ensure the date is a valid date
    if (!isNaN(date)) {
        const monday = getMonday(date);
        const weekDates = getWeekDates(monday);
        
        // Update table headers with the correct dates and day names
        updateTableHeaders(weekDates);
        getSelectedWeekStart();
    }
}
// Function to get the start date of the selected week (Monday)
function getSelectedWeekStart() {
    const selectedDate = document.getElementById('weekStartDate').value;
    if (selectedDate) {
        const date = new Date(selectedDate);
        return getMonday(date);  // Use the getMonday function to find the Monday of the selected week
    } else {
        // If no date is selected, return the current week's Monday
        const currentDate = new Date();
        return getMonday(currentDate);
    }
}
// Function to get the date of the Monday for the selected week
function getMonday(date) {
    const day = date.getDay(),
          diff = date.getDate() - day + (day == 0 ? -6 : 1); // Get Monday date
    return new Date(date.setDate(diff));
}
// Function to generate an array of dates for the week starting from Monday
function getWeekDates(monday) {
    const weekDates = [];
    for (let i = 0; i < 7; i++) {
        const day = new Date(monday);
        day.setDate(monday.getDate() + i);
        weekDates.push(day);
    }
    return weekDates;
}
// Function to update table headers with correct day format (dd/mm/yyyy (day))
function updateTableHeaders(weekDates) {
    const daysOfWeek = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
    
    // Loop through the days and update the headers
    daysOfWeek.forEach((day, index) => {
        const dayHeader = document.getElementById(`${day.toLowerCase()}Header`);
        const date = weekDates[index];
        const formattedDate = formatDate(date);
        dayHeader.innerText = `${formattedDate} (${day})`;
        dayHeader.dataset.date = formattedDate;
    });
}
// Helper function to format the date to dd/mm/yyyy
function formatDate(date) {
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0'); // Month is 0-based
    const year = date.getFullYear();
    return `${day}/${month}/${year}`;
}
// Function to fetch employees data and populate the table
function fetchEmployeeData() {
    // Fetch employee data from the backend
    fetch('/rota/employees')
        .then(response => response.json())
        .then(employees => {
            // Call function to populate employee rows with fetched data
            populateEmployeeRows(employees);
        })
        .catch(error => {
            console.error('Error fetching employee data:', error);
        });
}
// Function to populate employee rows in the table
function populateEmployeeRows(employees) {
    // Sort employees: BOH first, then FOH, within each by position, and finally by wage (descending order)
    employees.sort((a, b) => {
        if (a.designation === 'BOH' && b.designation !== 'BOH') {
            return -1; // BOH comes first
        } else if (a.designation !== 'BOH' && b.designation === 'BOH') {
            return 1; // FOH comes after BOH
        } else {
            // Sort within the same designation by position first
            const positionOrder = { manager: 1, supervisor: 2, tm: 3 };
            const positionComparison = (positionOrder[a.position] || 4) - (positionOrder[b.position] || 4);

            if (positionComparison !== 0) {
                return positionComparison; // Sort by position first
            }

            // If positions are the same, sort by wage (descending)
            return b.wage - a.wage;
        }
    });
    
    const employeeRowsContainer = document.getElementById('employeeRows');
    let employeeRowsHTML = '';
    employees.forEach(employee => {
        
        employeeRowsHTML += `
            <tr data-designation="${employee.designation}" data-position="${employee.position}">
            <td>${employee.name}</td>
            <td>${employee.lastName}</td>
            <td>${employee.wage}</td>
            <td>${employee.designation}</td>
            ${createTimeCells('monday')}
            ${createTimeCells('tuesday')}
            ${createTimeCells('wednesday')}
            ${createTimeCells('thursday')}
            ${createTimeCells('friday')}
            ${createTimeCells('saturday')}
            ${createTimeCells('sunday')}
            <td class="total-hours"></td>
            <td class="total-spent"></td>
        </tr>
            `;
    });
    employeeRowsContainer.innerHTML = employeeRowsHTML;
    // Apply initial cell colors based on designation
    applyRowColors();
    // Add event listeners to time input fields
    addTimeInputListeners();
    // Call funtion to fetch and display rota data
    fetchAndPopulateRotaTable();
}
// Apply row colors based on employee designation and position
function applyRowColors() {
    const rows = document.querySelectorAll('tr');
    rows.forEach(row => {
        const designation = row.getAttribute('data-designation');
        const position = row.getAttribute('data-position');
        const cells = row.querySelectorAll('td');

        cells.forEach((cell, index) => {
            if (position === 'manager' && designation === 'FOH') {
                if (index >= 0 && index <= 3) {
                    cell.style.backgroundColor = '#ffc0cb'; // Light Rose for Managers
                }
            } else if (position === 'supervisor') {
                if (index >= 0 && index <= 3) {
                    cell.style.backgroundColor = '#ffcc99'; // Light Orange for Supervisors
                }
            } else if (designation === 'BOH') {
                if (index >= 0 && index <= 3) {
                    cell.style.backgroundColor = '#fffacd'; // Light Yellow for BOH
                }
            } else if (designation === 'FOH') {
                if (index >= 0 && index <= 3) {
                    cell.style.backgroundColor = '#add8e6'; // Light Blue for FOH
                }
            }
        });
    });
}
// Toggle color between Light Blue (FOH), Light Yellow (BOH), and White (Reset)
function toggleColor(event, day) {
    const cell = event.target.closest('td');
    const currentColor = cell.style.backgroundColor;

    // Cycle through the colors in the order: Light Blue (FOH) -> Light Yellow (BOH) -> White (Reset)
    if (currentColor === 'rgb(173, 216, 230)' || currentColor === 'lightblue') { // Light Blue (FOH)
        cell.style.backgroundColor = '#fffacd'; // Change to Light Yellow (BOH)
        addTimeFrames(cell); // Add time frames back
    } else if (currentColor === 'rgb(255, 250, 205)' || currentColor === 'lightyellow') { // Light Yellow (BOH)
        cell.style.backgroundColor = '#ffffff'; // Change to White (Reset)
        addTimeFrames(cell); // Add time frames back
    } else { // White (Reset) or any other color
        cell.style.backgroundColor = '#add8e6'; // Change to Light Blue (FOH)
        addTimeFrames(cell); // Add time frames back
    }
}
// Main function to fetch and populate the rota table
function fetchAndPopulateRotaTable() {
    // Get the selected week's Monday date
    const selectedMonday = getSelectedWeekStart();

    // Get all the dates for the selected week (Monday to Sunday)
    const weekDates = getWeekDates(selectedMonday);

    // Format the week dates and create the query string
    const formattedWeekDates = weekDates.map(date => formatDateWithDay(date));
    const queryString = formattedWeekDates.join(',');

    // Fetch rota data using the dynamically created query string
    fetch(`/rota/rota?days=${queryString}`)
        .then(response => response.json())
        .then(groupedData => {

            // Clear all time input values and cell colors in the table
            document.querySelectorAll("#employeeRows input[type='time']").forEach(input => {
                input.value = ''; // Reset the time input
                input.style.display = ''; // Ensure inputs are visible by default
            });
            document.querySelectorAll("#employeeRows td").forEach(cell => {
                cell.style.backgroundColor = ''; // Reset the background color
            });

            // Fill in rota data for each day
            Object.keys(groupedData).forEach(day => {
                const employees = groupedData[day];
                if (Array.isArray(employees)) {
                    // Group entries by name and lastName
                    const employeeGroups = employees.reduce((acc, employee) => {
                        const key = `${employee.name}_${employee.lastName}`;
                        if (!acc[key]) {
                            acc[key] = [];
                        }
                        acc[key].push(employee);
                        return acc;
                    }, {});

                    Object.keys(employeeGroups).forEach(key => {
                        const [name, lastName] = key.split('_');
                        const groupedEntries = employeeGroups[key];

                        const dayOfWeek = getWeekdayFromDate(day);
                        if (!dayOfWeek) {
                            console.warn(`Invalid day format: ${day}`);
                            return;
                        }

                        const employeeRow = Array.from(document.querySelectorAll("#employeeRows tr")).find(row => {
                            const nameCell = row.children[0]?.textContent.trim();
                            const lastNameCell = row.children[1]?.textContent.trim();
                            return nameCell === name && lastNameCell === lastName;
                        });

                        if (employeeRow) {
                            const dayHeader = document.querySelector(`th[data-day="${dayOfWeek}"]`);
                            if (dayHeader) {
                                const dayIndex = Array.from(dayHeader.parentElement.children).indexOf(dayHeader);
                                const dayCell = employeeRow.children[dayIndex];

                                if (dayCell) {
                                    // Combine and sort all time frames for this employee on this day
                                    const timeFrames = groupedEntries
                                        .map(entry => ({
                                            start: entry.startTime || '',
                                            end: entry.endTime || '',
                                            color: entry.color || '' // Extract the color value
                                        }))
                                        .filter(frame => frame.start) // Ensure only valid frames are considered
                                        .sort((a, b) => a.start.localeCompare(b.start)); // Sort by start time

                                    // If there are no time frames, remove the inputs for "Off" state
                                    if (timeFrames.length === 0) {
                                        removeTimeFrames(dayCell);
                                    } else {
                                        // Flatten sorted time frames into four slots for two time periods
                                        const startTime1 = timeFrames[0]?.start || '';
                                        const endTime1 = timeFrames[0]?.end || '';
                                        const startTime2 = timeFrames[1]?.start || '';
                                        const endTime2 = timeFrames[1]?.end || '';
                                        const cellColor = timeFrames[0]?.color || ''; // Get the color value

                                        // Populate the inputs with new data
                                        const timeInputs = dayCell.querySelectorAll("input[type='time']");
                                        if (timeInputs[0]) {
                                            timeInputs[0].value = startTime1;
                                            timeInputs[0].style.display = ''; // Ensure input is visible
                                        }
                                        if (timeInputs[1]) {
                                            timeInputs[1].value = endTime1;
                                            timeInputs[1].style.display = ''; // Ensure input is visible
                                        }
                                        if (timeInputs[2]) {
                                            timeInputs[2].value = startTime2;
                                            timeInputs[2].style.display = ''; // Ensure input is visible
                                        }
                                        if (timeInputs[3]) {
                                            timeInputs[3].value = endTime2;
                                            timeInputs[3].style.display = ''; // Ensure input is visible
                                        }

                                        // Apply the color to the cell
                                        if (cellColor) {
                                            dayCell.style.backgroundColor = cellColor;
                                        }
                                    }
                                } else {
                                    console.warn(`No cell found for ${dayOfWeek} in row for ${name} ${lastName}`);
                                }
                            } else {
                                console.warn(`No header found for day: ${dayOfWeek}`);
                            }
                        } else {
                            console.warn(`Row for employee ${name} ${lastName} not found.`);
                        }
                    });
                } else {
                    console.error(`Data for day ${day} is not an array:`, employees);
                }
            });
            
            // After populating the table, check for empty cells and remove time frames if necessary
            checkAndRemoveEmptyTimeFrames();
            // Apply styles and event listeners
            applyRowColors();
            // Calculate total daily hours and total daily spent
            updateDailySpent();
            // Calculate total weekly hours and total weekly spent
            updateWeeklyTotals(); 
            // Calculate total hours for a row
            updateTotalHoursForRow();
            // Add event listeners to time input fields
            addTimeInputListeners(); 
            // Function to Fetch Holiday Data
            updateRotaWithHolidays();
        })
        .catch(error => {
            console.error('Error fetching rota data:', error);
        });
}
// Function to check all cells and remove empty time frames only if table has some data
function checkAndRemoveEmptyTimeFrames() {
    // Get all rows in the employee table
    const employeeRows = document.querySelectorAll("#employeeRows tr");
    let tableHasData = false;

    // First check if table has any data at all
    employeeRows.forEach(row => {
        const timeInputs = row.querySelectorAll('input[type="time"]');
        const hasData = Array.from(timeInputs).some(input => input.value !== '');
        if (hasData) {
            tableHasData = true;
        }
    });

    // If no data in entire table, leave all time frames
    if (!tableHasData) return;

    // If table has data, remove empty time frames
    employeeRows.forEach(row => {
        const dayCells = Array.from(row.querySelectorAll('td[data-day]'));
        dayCells.forEach(cell => {
            const timeInputs = cell.querySelectorAll('input[type="time"]');
            const allInputsEmpty = Array.from(timeInputs).every(input => input.value === '');
            
            if (allInputsEmpty) {
                removeTimeFrames(cell);
                // Add back one empty set if we removed everything
                if (cell.querySelectorAll('input[type="time"]').length === 0) {
                    addTimeFrames(cell);
                }
            }
        });
    });
}
// Extract day from full date
function getWeekdayFromDate(dateString) {
    // Extract the day of the week from the date string (e.g., "29/11/2024 (Friday)")
    const match = dateString.match(/\((\w+)\)/);
    if (match) {
        return match[1].toLowerCase();
    } else {
        console.warn(`No weekday found in date string: ${dateString}`);
        return null;
    }
}
// Helper function to format the date with the day
function formatDateWithDay(date) {
    const formattedDate = formatDate(date);  // Format as dd/mm/yyyy
    const dayOfWeek = date.toLocaleString('en-us', { weekday: 'long' }); // Get the day of the week
    return `${formattedDate} (${dayOfWeek})`;
}
// String replace helper to modify cell contents at the correct index
String.prototype.replaceAtIndex = function (replace, index, newValue) {
    const arr = this.split('');
    arr.splice(index, 1, newValue);
    return arr.join('');
}
// Add event listeners to time input fields (for example, to handle validation)
function addTimeInputListeners() {
    const timeInputs = document.querySelectorAll('input[type="time"]');
    timeInputs.forEach(input => {
        input.addEventListener('change', (e) => {
        });
    });
}
// Function to calculate total hours for a row
function updateTotalHoursForRow(row) {
    let totalHours = 0;

    // Get all the time input fields for the current row (start and end times)
    const timeInputs = row.querySelectorAll('input[type="time"]');
    
    // Loop through the inputs to calculate the total hours
    for (let i = 0; i < timeInputs.length; i += 2) {
        const startTime = timeInputs[i].value;
        const endTime = timeInputs[i + 1].value;

        // If both start and end time are provided, calculate the time difference
        if (startTime && endTime) {
            const start = parseTime(startTime);
            const end = parseTime(endTime);

            if (start && end) {
                let diff = (end - start) / (1000 * 60 * 60); // Convert milliseconds to hours
                
                // Handle crossing midnight
                if (diff < 0) {
                    diff += 24; // Add 24 hours to the difference
                }

                totalHours += diff;
            }
        }
    }

    // Update the "Total Hours" column in the current row
    const totalHoursCell = row.querySelector('.total-hours');
    totalHoursCell.textContent = totalHours.toFixed(2); // Round to 2 decimal places

    // Get the wage for the row
    const wageCell = row.querySelector('td:nth-child(3)'); // Assuming wage is in the 3rd column
    const wage = parseFloat(wageCell.textContent);

    // Calculate the total spent
    const totalSpent = totalHours * wage;

    // Update the "Total Spent" column in the current row
    const totalSpentCell = row.querySelector('.total-spent');
    totalSpentCell.textContent = `£ ${totalSpent.toFixed(2)}`; // Round to 2 decimal places
    updateDailySpent();
}
// Function to update weekly totals
function updateWeeklyTotals() {
    const totalRow = document.querySelector('#totalrow');
    const rows = document.querySelectorAll('#employeeRows tr');
    let weeklyTotalHours = 0;
    let weeklyTotalSpent = 0;
    const dayTotals = {
        monday: { hours: 0, spent: 0 },
        tuesday: { hours: 0, spent: 0 },
        wednesday: { hours: 0, spent: 0 },
        thursday: { hours: 0, spent: 0 },
        friday: { hours: 0, spent: 0 },
        saturday: { hours: 0, spent: 0 },
        sunday: { hours: 0, spent: 0 }
    };

    if (!totalRow) {
        console.error("Total row not found in the table.");
        return;
    }

    // Loop through each row to calculate weekly totals
    rows.forEach(row => {
        let totalHoursForRow = 0;
        let totalSpentForRow = 0;
        const wage = parseFloat(row.querySelector('td:nth-child(3)').textContent) || 0;

        // Loop through each day column (Monday to Sunday)
        const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
        days.forEach((day, index) => {
            const dayCell = row.querySelector(`td[data-day="${day}"]`);
            if (!dayCell) return;

            let totalHoursForDay = 0;
            const timeInputs = dayCell.querySelectorAll('input[type="time"]');

            // Calculate hours for each time slot
            for (let i = 0; i < timeInputs.length; i += 2) {
                const startTime = timeInputs[i]?.value;
                const endTime = timeInputs[i + 1]?.value;

                if (startTime && endTime) {
                    const start = parseTime(startTime);
                    const end = parseTime(endTime);

                    if (start && end) {
                        let diff = (end - start) / (1000 * 60 * 60); // Convert to hours
                        if (diff < 0) diff += 24; // Handle midnight crossing
                        totalHoursForDay += diff;
                    }
                }
            }

            // Update day totals
            dayTotals[day].hours += totalHoursForDay;
            dayTotals[day].spent += totalHoursForDay * wage;
            
            // Update the day cell to show both hours and pounds
            const existingSpan = dayCell.querySelector('.day-total');
            if (existingSpan) {
                existingSpan.textContent = `${totalHoursForDay.toFixed(2)}h / £${(totalHoursForDay * wage).toFixed(2)}`;
            } else {
                const totalSpan = document.createElement('span');
                totalSpan.className = 'day-total';
                totalSpan.textContent = `${totalHoursForDay.toFixed(2)}h / £${(totalHoursForDay * wage).toFixed(2)}`;
                dayCell.appendChild(document.createElement('br'));
                dayCell.appendChild(totalSpan);
            }

            totalHoursForRow += totalHoursForDay;
            totalSpentForRow += totalHoursForDay * wage;
        });

        // Update row's total hours and spent
        const totalHoursCell = row.querySelector('td:nth-last-child(2)'); // Second last cell
        const totalSpentCell = row.querySelector('td:last-child'); // Last cell
        
        if (totalHoursCell) {
            totalHoursCell.textContent = `${totalHoursForRow.toFixed(2)}h`;
        }
        if (totalSpentCell) {
            totalSpentCell.textContent = `£${totalSpentForRow.toFixed(2)}`;
        }

        weeklyTotalHours += totalHoursForRow;
        weeklyTotalSpent += totalSpentForRow;
    });

    // Update day totals in footer
    Object.entries(dayTotals).forEach(([day, totals]) => {
        const dayTotalCell = totalRow.querySelector(`td[data-day="${day}"]`);
        if (dayTotalCell) {
            dayTotalCell.textContent = `${totals.hours.toFixed(2)}h / £${totals.spent.toFixed(2)}`;
        }
    });

    // Update weekly totals
    const weeklyHoursTotal = document.getElementById('weeklyHoursTotal');
    const weeklySpentTotal = document.getElementById('weeklySpentTotal');
    
    if (weeklyHoursTotal) weeklyHoursTotal.textContent = `${weeklyTotalHours.toFixed(2)}h`;
    if (weeklySpentTotal) weeklySpentTotal.textContent = `£${weeklyTotalSpent.toFixed(2)}`;

    // Update other calculations
    calculateHolidayPercentage();
    calculateTaxPercentage();
    calculatePensionPercentage();
    calculateTotalCostWeek();
    // Call this when you need to sync from day totals to labor inputs
    updateLaborInputsFromDayTotals();
}
// Helper function to get the total pounds value
function getTotalPoundsValue() {
    // Try to get the value from weeklySpentTotal first
    const weeklyTotalElement = document.getElementById('weeklySpentTotal');
    if (weeklyTotalElement) {
        const text = weeklyTotalElement.textContent.trim();
        return parseFloat(text.replace('£', '')) || 0;
    }
    
    // Fallback to total row if weeklySpentTotal not found
    const totalRow = document.querySelector('#totalrow');
    if (totalRow) {
        // Try to find a cell containing £ (this might need adjustment based on your actual HTML)
        const poundCells = totalRow.querySelectorAll('td:contains("£")');
        if (poundCells.length > 0) {
            const text = poundCells[0].textContent.trim();
            const poundValue = text.split('£')[1] || text.replace('£', '');
            return parseFloat(poundValue) || 0;
        }
    }
    
    return 0;
}
// Calculates the holiday percentage of the total value
function calculateHolidayPercentage() {
    const percentageValue = parseFloat(document.getElementById('holidayPercentageInput').value) || 0;
    const totalValue = getTotalPoundsValue();
    const result = (percentageValue / 100) * totalValue;
    const resultElement = document.getElementById('result-holiday');
    if (resultElement) {
        resultElement.textContent = `£${result.toFixed(2)}`;
    }
}
// Calculates the tax percentage of the total value
function calculateTaxPercentage() {
    const taxValue = parseFloat(document.getElementById('taxPercentageInput').value) || 0;
    const totalValue = getTotalPoundsValue();
    const result = (taxValue / 100) * totalValue;
    const resultElement = document.getElementById('result-tax');
    if (resultElement) {
        resultElement.textContent = `£${result.toFixed(2)}`;
    }
}
// Calculates the pension percentage of the total value
function calculatePensionPercentage() {
    const pensionValue = parseFloat(document.getElementById('pensionPercentageInput').value) || 0;
    const totalValue = getTotalPoundsValue();
    const result = (pensionValue / 100) * totalValue;
    const resultElement = document.getElementById('result-pension');
    if (resultElement) {
        resultElement.textContent = `£${result.toFixed(2)}`;
    }
}
// Make sure to call updateWeeklyTotals() when inputs change
document.getElementById('holidayPercentageInput')?.addEventListener('input', calculateHolidayPercentage);
document.getElementById('taxPercentageInput')?.addEventListener('input', calculateTaxPercentage);
document.getElementById('pensionPercentageInput')?.addEventListener('input', calculatePensionPercentage);
// Function to Calculate the Total Weekly Cost
function calculateTotalCostWeek() {
    try {
        // Helper function to parse a value, remove £ symbol, and convert it to a float
        const parseValue = (selector) => {
            const cell = document.querySelector(selector);
            if (cell) {
                return parseFloat(cell.textContent.replace('£', '').trim()) || 0;
            }
            return 0;
        };

        // Get the values from the relevant cells
        const pensionValue = parseValue('#result-pension');
        const taxValue = parseValue('#result-tax');
        const holidayValue = parseValue('#result-holiday');
        const totalRowValue = getTotalPoundsValue();

        // Sum the values
        const totalCost = pensionValue + taxValue + holidayValue + totalRowValue;

        // Update the total cost in the cell #totalcostweek
        const totalCostWeekCell = document.querySelector('#totalcostweek');
        if (totalCostWeekCell) {
            totalCostWeekCell.textContent = `£ ${totalCost.toFixed(2)}`;
        } else {
            console.error('Cell with ID #totalcostweek not found.');
        }
    } catch (error) {
        console.error('Error calculating total cost for the week:', error);
    }
}
// Function to calculate total daily hours and total daily spent
function updateDailySpent() {
    const rows = document.querySelectorAll('#employeeRows tr'); // Select all rows

    const dailyTotals = Array(7).fill(0); // Array to store total hours for each day (Monday to Sunday)
    const dailySpentTotals = Array(7).fill(0); // Array to store total spent for each day (Monday to Sunday)

    rows.forEach((row, rowIndex) => {
        let totalHoursForRow = 0;

        // Get wage for the current row
        const wageCell = row.querySelector('td:nth-child(3)');
        let wage = parseFloat(wageCell?.textContent?.trim()) || 0;

        // Loop through columns for Monday to Sunday (5 to 11)
        for (let columnIndex = 5; columnIndex <= 11; columnIndex++) {
            let totalHoursForDay = 0;

            // Select time inputs for the current column
            const timeInputs = row.querySelectorAll(`td:nth-child(${columnIndex}) input[type="time"]`);

            // Ensure there are exactly 4 time inputs (2 pairs: start and end)
            if (timeInputs.length === 4) {
                for (let i = 0; i < 2; i++) {
                    const startTime = timeInputs[i * 2]?.value;
                    const endTime = timeInputs[i * 2 + 1]?.value;

                    if (startTime && endTime) {
                        const start = parseTime(startTime);
                        const end = parseTime(endTime);

                        if (start && end) {
                            let diff = (end - start) / (1000 * 60 * 60); // Convert ms to hours
                            if (diff < 0) diff += 24; // Handle crossing midnight

                            totalHoursForDay += diff;
                        }
                    }
                }
            } else {
                console.warn(`Expected 4 inputs, but found ${timeInputs.length} in column ${columnIndex}`);
            }

            totalHoursForRow += totalHoursForDay;
            dailyTotals[columnIndex - 5] += totalHoursForDay; // Add the hours to the daily total array
            dailySpentTotals[columnIndex - 5] += totalHoursForDay * wage; // Add to the total spent for the day
        }

        // Calculate total spent for the row
        const totalSpentForRow = totalHoursForRow * wage;

        // Update total spent column for the current row
        const totalSpentCell = row.querySelector('td:nth-child(13)');
        if (totalSpentCell) {
            totalSpentCell.textContent = `£${totalSpentForRow.toFixed(2)}`;
        }
    });

    // Update the #totalrow with the aggregated daily totals
    dailyTotals.forEach((total, index) => {
        const totalsRowCell = document.querySelector(`#totalrow td:nth-child(${index + 5})`);
        if (totalsRowCell) {
            totalsRowCell.textContent = `${total.toFixed(2)} hrs`; // Display the total hours for the day
        }
    });

    // Update the #totalrow with the aggregated daily spent totals
    dailySpentTotals.forEach((total, index) => {
        const totalsSpentRowCell = document.querySelector(`#totalrow td:nth-child(${index + 5})`);
        if (totalsSpentRowCell) {
            totalsSpentRowCell.textContent += ` / £${total.toFixed(2)}`; // Append the total spent for the day
        }
    });
    updateWeeklyTotals();
}
// Function to parse time string (HH:mm) into a Date object
function parseTime(timeStr) {
    const [hours, minutes] = timeStr.split(':').map(Number);
    const date = new Date();
    date.setHours(hours);
    date.setMinutes(minutes);
    date.setSeconds(0);
    date.setMilliseconds(0);
    return date;
}
// Function to add event listeners to time input fields
function addTimeInputListeners() {
    // Get all time input fields
    const timeInputs = document.querySelectorAll('input[type="time"]');

    // Loop through each input field and add an event listener
    timeInputs.forEach(input => {
        input.addEventListener('input', () => {
            const row = input.closest('tr');
            updateTotalHoursForRow(row);  // Update total hours and total spent for the current row
            updateWeeklyTotals();  // Update weekly totals
            updateDailySpent();  // Update daily totals
        });
    });
}
// Function to send Rota data to the BackEnd
function saveRotaData() {
    const tableData = [];
    const rows = document.querySelectorAll("#employeeRows tr"); // Ensure correct row selector

    // Get the week start date from input (in yyyy-mm-dd format)
    let weekStartDate = document.getElementById('weekStartDate')?.value;

    // Determine the starting Monday date
    let date;
    if (weekStartDate) {
        // Parse the provided date
        date = new Date(weekStartDate);
    } else {
        // Default to the current date
        date = new Date();
    }

    // Ensure the date is valid
    if (isNaN(date)) {
        console.error("Invalid week start date.");
        return;
    }

    // Get the Monday of the week (if it's not already Monday)
    const monday = getMonday(date);

    // Format the Monday date and get the day of the week
    const dayOfWeek = getDayOfWeek(monday);
    const formattedMonday = formatDate(monday);

    // Rebuild the week start date with the Monday and day of the week
    weekStartDate = `${formattedMonday} (${dayOfWeek})`;

    // Get the week dates (the full dates for the week starting from Monday)
    const weekDates = getWeekDates(monday); // Get array of full Date objects for the week

    // Iterate through each row and prepare the data
    rows.forEach(row => {
        const name = row.children[0]?.textContent.trim();
        const lastName = row.children[1]?.textContent.trim();
        const wage = row.children[2]?.textContent.trim();
        const designation = row.children[3]?.textContent.trim();

        // Iterate through each day column to extract time values and background color
        for (let i = 4; i < row.children.length - 2; i++) { // Skip last two columns
            const cell = row.children[i];
            const dayOfWeek = cell.getAttribute('data-day'); // Correct way to get data-day

            if (!dayOfWeek) continue;

            const inputs = cell.querySelectorAll("input[type='time']");
            const backgroundColor = cell.style.backgroundColor; // Extract the background color
            if (inputs.length < 2) continue; // Skip if there are no time inputs

            const startTime1 = inputs[0]?.value || "";
            const endTime1 = inputs[1]?.value || "";
            const startTime2 = inputs[2]?.value || "";
            const endTime2 = inputs[3]?.value || "";

            // Get the corresponding date for the current day in the week
            const currentDate = weekDates[i - 4]; // Map the index to the correct day in the week
            const formattedDate = formatDate(currentDate); // Use the formatDate function to format the date

            // Get the day of the week (e.g., "Monday", "Tuesday")
            const dayOfWeekForDate = getDayOfWeek(currentDate);

            // Combine date and day of the week into one string like "dd/mm/yyyy (Day)"
            const dayWithDayOfWeek = `${formattedDate} (${dayOfWeekForDate})`;

            // Add data to the tableData array with day and dayOfWeek combined
            if (startTime1 && endTime1) {
                tableData.push({
                    name, lastName, wage, designation, day: dayWithDayOfWeek,
                    startTime: startTime1, endTime: endTime1, color: backgroundColor
                });
            }
            if (startTime2 && endTime2) {
                tableData.push({
                    name, lastName, wage, designation, day: dayWithDayOfWeek,
                    startTime: startTime2, endTime: endTime2, color: backgroundColor
                });
            }
        }
    });


    // Send data to the backend using fetch API (adjust the URL to your backend)
    fetch('/rota/saveData', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(tableData),
    })
    .then(response => response.text())
    .then(data => {
        alert('Rota saved successfully!');
    })
    .catch(error => {
        console.error('Error:', error);
    });
}
// Function to Submit Rota, Generate PDF and Send Email
function submitRotaData() {
    const tableData = [];
    const rows = document.querySelectorAll("#employeeRows tr"); // Ensure correct row selector

    // Get the week start date from input (in yyyy-mm-dd format)
    let weekStartDate = document.getElementById('weekStartDate')?.value;

    // Determine the starting Monday date
    let date;
    if (weekStartDate) {
        // Parse the provided date
        date = new Date(weekStartDate);
    } else {
        // Default to the current date
        date = new Date();
    }

    // Ensure the date is valid
    if (isNaN(date)) {
        console.error("Invalid week start date.");
        return;
    }

    // Get the Monday of the week (if it's not already Monday)
    const monday = getMonday(date);

    // Format the Monday date and get the day of the week
    const dayOfWeek = getDayOfWeek(monday);
    const formattedMonday = formatDate(monday);

    // Rebuild the week start date with the Monday and day of the week
    weekStartDate = `${formattedMonday} (${dayOfWeek})`;

    // Get the week dates (the full dates for the week starting from Monday)
    const weekDates = getWeekDates(monday); // Get array of full Date objects for the week

    // Iterate through each row and prepare the data
    rows.forEach(row => {
        const name = row.children[0]?.textContent.trim();
        const lastName = row.children[1]?.textContent.trim();
        const wage = row.children[2]?.textContent.trim();
        const designation = row.children[3]?.textContent.trim();

        // Iterate through each day column to extract time values and background color
        for (let i = 4; i < row.children.length - 2; i++) { // Skip last two columns
            const cell = row.children[i];
            const dayOfWeek = cell.getAttribute('data-day'); // Correct way to get data-day

            if (!dayOfWeek) continue;

            const inputs = cell.querySelectorAll("input[type='time']");
            const backgroundColor = cell.style.backgroundColor; // Extract the background color
            if (inputs.length < 2) continue; // Skip if there are no time inputs

            const startTime1 = inputs[0]?.value || "";
            const endTime1 = inputs[1]?.value || "";
            const startTime2 = inputs[2]?.value || "";
            const endTime2 = inputs[3]?.value || "";

            // Get the corresponding date for the current day in the week
            const currentDate = weekDates[i - 4]; // Map the index to the correct day in the week
            const formattedDate = formatDate(currentDate); // Use the formatDate function to format the date

            // Get the day of the week (e.g., "Monday", "Tuesday")
            const dayOfWeekForDate = getDayOfWeek(currentDate);

            // Combine date and day of the week into one string like "dd/mm/yyyy (Day)"
            const dayWithDayOfWeek = `${formattedDate} (${dayOfWeekForDate})`;

            // Add data to the tableData array with day and dayOfWeek combined
            if (startTime1 && endTime1) {
                tableData.push({
                    name, lastName, wage, designation, day: dayWithDayOfWeek,
                    startTime: startTime1, endTime: endTime1, color: backgroundColor
                });
            }
            if (startTime2 && endTime2) {
                tableData.push({
                    name, lastName, wage, designation, day: dayWithDayOfWeek,
                    startTime: startTime2, endTime: endTime2, color: backgroundColor
                });
            }
        }
    });


    // Send data to the backend using fetch API (adjust the URL to your backend)
    fetch('/rota/submitData', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(tableData),
    })
    .then(response => response.text())
    .then(data => {
        alert('Rota saved Successfully and Notifications are Sent!');
    })
    .catch(error => {
        console.error('Error:', error);
    });
}
// Function to color cells based on holidays/unpaid leave
function updateRotaWithHolidays() {
    // Clear existing colors first
    document.querySelectorAll('tbody td').forEach(cell => {
        if (cell.style.backgroundColor === 'lightgreen' || cell.style.backgroundColor === 'lightgrey') {
            cell.style.backgroundColor = '';
        }
    });

    // Fetch holidays from the backend
    fetch('/rota/holidays')
        .then(async response => {
            if (!response.ok) throw new Error(`Server error: ${response.status}`);
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                buffer += decoder.decode(value, { stream: true });
                
                // Process each complete JSON object we've received
                while (buffer.includes('{') && buffer.includes('}')) {
                    const start = buffer.indexOf('{');
                    const end = buffer.indexOf('}') + 1;
                    const jsonStr = buffer.substring(start, end);
                    buffer = buffer.substring(end);
                    
                    try {
                        const holiday = JSON.parse(jsonStr);
                        processHolidayRecord(holiday);
                    } catch (e) {
                        console.error('Error parsing JSON:', e);
                    }
                }
            }
        })
        .catch(error => {
            console.error('Failed to fetch holidays:', error);
            // Show user-friendly error message if needed
        });
}
// Helper function to process each holiday record
function processHolidayRecord(holiday) {
    const { name, lastname, startDate, endDate, accepted } = holiday;
    
    // Validate required fields
    if (!name || !lastname || !startDate || !endDate) {
        console.warn('Skipping incomplete holiday record:', holiday);
        return;
    }

    // Parse dates (assuming format: dd/mm/yyyy (Day))
    const parseHolidayDate = (dateStr) => {
        const [datePart, dayPart] = dateStr.split(' (');
        const [day, month, year] = datePart.split('/');
        return new Date(`${year}-${month}-${day}`);
    };

    const start = parseHolidayDate(startDate);
    const end = parseHolidayDate(endDate);

    // Find employee row (case-insensitive)
    const employeeRow = Array.from(document.querySelectorAll('tbody tr')).find(row => {
        const rowName = row.cells[0]?.textContent.trim().toLowerCase();
        const rowLastName = row.cells[1]?.textContent.trim().toLowerCase();
        return rowName === name.toLowerCase() && rowLastName === lastname.toLowerCase();
    });

    if (!employeeRow) {
        console.warn(`Employee not found: ${name} ${lastname}`);
        return;
    }

    // Get all day headers
    const headerCells = Array.from(document.querySelectorAll('thead th[data-day]'));
    
    // Determine color based on leave type
    const cellColor = accepted === 'true' ? 'lightgreen' : 'lightgrey';
    
    // Process each day in the holiday range
    for (let date = new Date(start); date <= end; date.setDate(date.getDate() + 1)) {
        const dayName = date.toLocaleDateString('en-GB', { weekday: 'long' });
        const formattedDate = `${String(date.getDate()).padStart(2, '0')}/${String(date.getMonth() + 1).padStart(2, '0')}/${date.getFullYear()} (${dayName})`;

        // Find matching day cell in header
        const dayCell = headerCells.find(cell => {
            return cell.textContent.trim() === formattedDate;
        });

        if (dayCell) {
            const dayIndex = dayCell.cellIndex;
            const employeeDayCell = employeeRow.cells[dayIndex];
            
            if (employeeDayCell) {
                // Check if cell has time inputs with values
                const hasTimeInputs = Array.from(employeeDayCell.querySelectorAll('input'))
                    .some(input => input.value.trim() !== '');
                
                // Only color the cell if it doesn't have time inputs with values
                if (!hasTimeInputs) {
                    employeeDayCell.style.backgroundColor = cellColor;
                } else {
                    // Optional: Add a different visual indicator for holidays with existing time entries
                    employeeDayCell.style.backgroundColor = cellColor;
                }
            }
        }
    }
}
// Add this to your main application code
document.querySelectorAll('[data-tab]').forEach(tab => {
    tab.addEventListener('click', function(e) {
        e.preventDefault();
        
        // Hide all tabs
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });
        
        // Show selected tab
        const tabId = this.dataset.tab;
        const content = document.getElementById(tabId);
        if (content) {
            content.classList.add('active');
            
            // Initialize holiday tab if it's the first activation
            if (tabId === 'holiday-tab' && !content.dataset.initialized) {
                initHolidayTab();
                content.dataset.initialized = true;
            }
        }
    });
});
// Global variable to track current week
let currentWeekStart = getMonday(new Date());
// Initialize holiday tab
function initHolidayTab() {
    // Set default dates
    const today = new Date();
    document.getElementById('startDate').valueAsDate = today;
    document.getElementById('endDate').valueAsDate = today;
    
    // Load employees and set up event listeners
    loadEmployees();
    setupHolidayEventListeners();
    
    // Initialize week view
    initWeekNavigation();
    loadHolidaysForWeek();
}
// Initialize week navigation
function initWeekNavigation() {
    const weekSelector = document.getElementById('weekSelector');
    
    // Set initial value to today
    weekSelector.valueAsDate = new Date();
    
    // When date changes, update the week view
    weekSelector.addEventListener('change', () => {
        if (weekSelector.value) {
            currentWeekStart = getMonday(new Date(weekSelector.value));
            updateWeekSelector();
            updateWeekDisplay();
            loadHolidaysForWeek();
        }
    });
    
    // Previous week button
    document.getElementById('prevWeek').addEventListener('click', () => {
        currentWeekStart.setDate(currentWeekStart.getDate() - 7);
        updateWeekSelector();
        updateWeekDisplay();
        loadHolidaysForWeek();
    });
    
    // Next week button
    document.getElementById('nextWeek').addEventListener('click', () => {
        currentWeekStart.setDate(currentWeekStart.getDate() + 7);
        updateWeekSelector();
        updateWeekDisplay();
        loadHolidaysForWeek();
    });
    
    updateWeekDisplay();
}
// Update the date picker to show Monday of current week
function updateWeekSelector() {
    document.getElementById('weekSelector').valueAsDate = currentWeekStart;
}
// Update getMonday function to prevent date mutation
function getMonday(date) {
    const d = new Date(date);
    const day = d.getDay();
    const diff = d.getDate() - day + (day === 0 ? -6 : 1);
    return new Date(d.getFullYear(), d.getMonth(), diff);
}
// Update week display text
function updateWeekDisplay() {
    const weekEnd = new Date(currentWeekStart);
    weekEnd.setDate(weekEnd.getDate() + 6);
    
    const options = { day: 'numeric', month: 'numeric', year: 'numeric' };
    const startStr = currentWeekStart.toLocaleDateString('en-GB', options);
    const endStr = weekEnd.toLocaleDateString('en-GB', options);
    
    document.getElementById('weekDisplay').textContent = `${startStr} - ${endStr}`;
}
// Convert date to dd/mm/yyyy (Day) format for database
function formatDateForDB(date) {
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    const dayName = date.toLocaleDateString('en-GB', { weekday: 'long' });
    return `${day}/${month}/${year} (${dayName})`;
}
// Parse dd/mm/yyyy (Day) format from database
function parseDBDate(dateStr) {
    const [datePart, dayPart] = dateStr.split(' (');
    const [day, month, year] = datePart.split('/');
    return new Date(`${year}-${month}-${day}`);
}
// Format date for API (YYYY-MM-DD)
function formatDateForAPI(date) {
    return date.toISOString().split('T')[0];
}
// Format date for display (dd/mm/yyyy (Day))
function formatDateForDisplay(date) {
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    const dayName = date.toLocaleDateString('en-GB', { weekday: 'long' });
    return `${day}/${month}/${year} (${dayName})`;
}
// Function to retrieve Holiday and Unpaid Leave Data
function loadHolidaysForWeek() {
    console.log('Loading holidays for week starting:', currentWeekStart);
    
    const weekEnd = new Date(currentWeekStart);
    weekEnd.setDate(weekEnd.getDate() + 6);
    
    // Format dates for API request (dd/mm/yyyy (Day))
    const startParam = formatDateForDB(currentWeekStart);
    const endParam = formatDateForDB(weekEnd);
    console.log('API parameters:', { start: startParam, end: endParam });

    fetch(`/rota/holidays-by-week?start=${encodeURIComponent(startParam)}&end=${encodeURIComponent(endParam)}`)
        .then(response => {
            console.log('API response status:', response.status);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return response.json();
        })
        .then(records => {
            console.log('Received records:', records);
            renderHolidayTable(records);
        })
        .catch(error => {
            console.error('Error loading records:', error);
            alert('Failed to load holiday/unpaid leave data. Please try again.');
        });
}
// Function to insert Holiday and Unpaid Leave Data into table
function renderHolidayTable(records) {
    const tbody = document.querySelector('#holidayTable tbody');
    if (!tbody) {
        console.error('Holiday table body not found');
        return;
    }
    tbody.innerHTML = '';
    
    try {
        // Update day headers with formatted dates
        const dayHeaders = document.querySelectorAll('.day-header');
        const weekDates = [];
        
        // Store all dates for the current week view
        for (let i = 0; i < 7; i++) {
            const dayDate = new Date(currentWeekStart);
            dayDate.setDate(dayDate.getDate() + i);
            weekDates.push(dayDate);
            if (dayHeaders[i]) {
                dayHeaders[i].textContent = formatDateForDisplay(dayDate);
            }
        }
        
        // Group records by employee
        const recordsByEmployee = {};
        records.forEach(record => {
            const key = `${record.name}|${record.lastName}`;
            if (!recordsByEmployee[key]) {
                recordsByEmployee[key] = [];
            }
            recordsByEmployee[key].push(record);
        });
        
        // Create rows for each employee
        Object.entries(recordsByEmployee).forEach(([employeeKey, employeeRecords]) => {
            const [name, lastName] = employeeKey.split('|');
            const row = document.createElement('tr');
            
            // Employee name cell
            const nameCell = document.createElement('td');
            nameCell.textContent = `${lastName}, ${name}`;
            row.appendChild(nameCell);
            
            // Create cells for each day of the week
            weekDates.forEach(dayDate => {
                const dayCell = document.createElement('td');
                
// Modify the recordForDay finder logic to ensure proper date comparison
const recordForDay = employeeRecords.find(record => {
    try {
        const start = parseDBDate(record.startDate);
        const end = parseDBDate(record.endDate);
        
        // Normalize all dates to midnight for comparison
        const currentDate = new Date(dayDate);
        currentDate.setHours(0, 0, 0, 0);
        start.setHours(0, 0, 0, 0);
        end.setHours(0, 0, 0, 0);
        
        return currentDate >= start && currentDate <= end;
    } catch (e) {
        console.error('Error parsing record dates:', e);
        return false;
    }
});
                if (recordForDay) {
                    if (recordForDay.type === 'holiday') {
                        dayCell.classList.add('holiday-cell');
                        dayCell.textContent = 'Holiday';
                        dayCell.style.backgroundColor = 'lightgreen';
                    } else {
                        dayCell.classList.add('unpaid-cell');
                        dayCell.textContent = 'Unpaid';
                        dayCell.style.backgroundColor = 'lightgrey';
                    }
                    dayCell.title = `${recordForDay.type === 'holiday' ? 'Holiday' : 'Unpaid Leave'} from ${recordForDay.startDate} to ${recordForDay.endDate}`;
                }
                
                row.appendChild(dayCell);
            });
            
            tbody.appendChild(row);
        });
    } catch (error) {
        console.error('Error rendering holiday table:', error);
        tbody.innerHTML = '<tr><td colspan="8">Error loading holiday/unpaid leave data</td></tr>';
    }
}
// DOM Elements
const holidayElements = {
    employeeSelect: document.getElementById('employeeSelect'),
    startDate: document.getElementById('startDate'),
    endDate: document.getElementById('endDate'),
    daysCalculated: document.getElementById('daysCalculated')
};
// Load employees for dropdown
function loadEmployees() {
    fetch('/rota/employees-holiday')
        .then(response => {
            if (!response.ok) throw new Error('Failed to load employees');
            return response.json();
        })
        .then(employees => {
            populateEmployeeDropdown(employees);
        })
        .catch(error => {
            console.error('Error loading employees:', error);
            holidayElements.employeeSelect.innerHTML = '<option value="">Error loading employees</option>';
        });
}
// Populate employee dropdown
function populateEmployeeDropdown(employees) {
    const select = holidayElements.employeeSelect;
    select.innerHTML = '<option value="">Select Employee</option>';
    
    employees.forEach(employee => {
        const option = document.createElement('option');
        option.value = `${employee.name}|${employee.lastname}|${employee.Accrued}|${employee.TotalHoliday}`;
        option.textContent = `${employee.lastname}, ${employee.name}, Accrued (${employee.Accrued}), Holidays Left (${employee.TotalHoliday})`;
        select.appendChild(option);
    });
}
// Set up event listeners
function setupHolidayEventListeners() {
    holidayElements.startDate.addEventListener('change', calculateDays);
    holidayElements.endDate.addEventListener('change', calculateDays);
}
// Calculate days between dates
function calculateDays() {
    const start = new Date(holidayElements.startDate.value);
    const end = new Date(holidayElements.endDate.value);
    
    if (isNaN(start) || isNaN(end)) return;
    
    // Ensure end date is not before start date
    if (end < start) {
        holidayElements.endDate.valueAsDate = start;
        holidayElements.daysCalculated.textContent = '1';
        return;
    }
    
    const days = Math.ceil((end - start) / (1000 * 60 * 60 * 24)) + 1;
    holidayElements.daysCalculated.textContent = days;
}
// Function to Submit Holidays or Unpaid Leave
function submitHolidayRequest() {
    const employee = holidayElements.employeeSelect.value;
    const startDate = holidayElements.startDate.value;
    const endDate = holidayElements.endDate.value;
    const requestType = document.querySelector('input[name="requestType"]:checked').value;
    
    if (!employee || !startDate || !endDate) {
        alert('Please select an employee and date range');
        return;
    }
    
    const [name, lastName] = employee.split('|');
    const requestData = { 
        name: name.trim(), 
        lastName: lastName.trim(), 
        startDate, 
        endDate,
        requestType // Add the request type to the data
    };
    
    fetch('/rota/submit-holiday', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestData)
    })
    .then(response => {
        if (!response.ok) {
            return response.json().then(err => { throw err; });
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            const requestTypeName = requestType === 'holiday' ? 'Holiday' : 'Unpaid Leave';
            alert(`${requestTypeName} Saved successfully!`);
            resetHolidayForm();
        } else {
            throw new Error(data.message || 'Submission failed');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert(`Error: ${error.message}`);
    });
}
// Reset form after submission
function resetHolidayForm() {
    holidayElements.employeeSelect.value = '';
    holidayElements.startDate.value = '';
    holidayElements.endDate.value = '';
    holidayElements.daysCalculated.textContent = '0';
}
// Call the function after page load with a 1-second delay
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(updateRotaWithHolidays, 1000);
});
// Function to create the input fields for each day
function createTimeCells(day, startTime1, endTime1, startTime2, endTime2) {
    // Check if any time inputs have actual values (not empty/default)
    const hasTimeValues = [startTime1, endTime1, startTime2, endTime2].some(
        time => time && time.trim() !== '' && !time.startsWith('00:00') && time !== '--:--'
    );

    // Set button state - "Off" when values exist, "On" when empty
    const buttonText = hasTimeValues ? 'Off' : 'On';
    const buttonClass = hasTimeValues ? '' : 'off-state';
    const buttonStyle = hasTimeValues ? '' : 'background-color:white;color:black;';
    const inputDisplay = hasTimeValues ? 'inline' : 'none';

    // Create a unique identifier for each day's inputs to attach event listeners
    const dayId = day.toLowerCase();

    return `
        <td class="day-cell" data-day="${day}" draggable="true"
            ondragstart="handleDragStart(event)"
            ondragover="handleDragOver(event)"
            ondrop="handleDrop(event)">
            
            <!-- Always create 4 time inputs, but control visibility -->
            <input type="time" class="time-input" data-day="${day}" id="start1-${dayId}"
                   value="${startTime1 || ''}" style="display:${inputDisplay}"
                   onchange="handleTimeChange('${day}')">
            <input type="time" class="time-input" data-day="${day}" id="end1-${dayId}"
                   value="${endTime1 || ''}" style="display:${inputDisplay}"
                   onchange="handleTimeChange('${day}')"><br>
            <input type="time" class="time-input" data-day="${day}" id="start2-${dayId}"
                   value="${startTime2 || ''}" style="display:${inputDisplay}"
                   onchange="handleTimeChange('${day}')">
            <input type="time" class="time-input" data-day="${day}" id="end2-${dayId}"
                   value="${endTime2 || ''}" style="display:${inputDisplay}"
                   onchange="handleTimeChange('${day}')"><br>
            
            <!-- Action Buttons -->
            <button class="write-off-btn" onclick="toggleColor(event, '${day}')">Swap</button>
            <button class="write-off-btn ${buttonClass}"
                    onclick="writeOff(event, '${day}')"
                    style="${buttonStyle}">
                ${buttonText}
            </button>
        </td>
    `;
}
// New function to handle time changes and update calculations
function handleTimeChange(day) {
    updateTotalHoursForRow();
}
// Function to handle the Write Off button click
function writeOff(event, dayIndex) {
    const cell = event.target.closest('td');
    const button = event.target;
    const row = cell.closest('tr');
    const timeInputs = cell.querySelectorAll('input[type="time"]');

    // Check current button state (not time values)
    const isCurrentlyActive = button.textContent.trim() === 'Off';

    if (isCurrentlyActive) {
        // Currently active ("Off" button) - switch to inactive
        button.textContent = 'On';
        button.style.backgroundColor = 'white';
        button.style.color = 'black';
        button.classList.add('off-state');
        
        // Clear and hide time inputs
        timeInputs.forEach(input => {
            input.value = '';
            input.style.display = 'none';
        });

        // Remove data from backend
        const name = row.children[0].textContent.trim();
        const lastName = row.children[1].textContent.trim();
        const fullDay = getFormattedDateForDay(dayIndex);
        if (fullDay) {
            removeTimeFrames(cell);
            removeDayDataFromDB(name, lastName, fullDay);
        }
    } else {
        // Currently inactive ("On" button) - switch to active
        button.textContent = 'Off';
        button.style.backgroundColor = '';
        button.style.color = '';
        button.classList.remove('off-state');
        
        // Show time inputs
        timeInputs.forEach(input => {
            input.style.display = 'inline';
        });
    }

    updateTotalHoursForRow(row);
    updateWeeklyTotals();
    updateDailySpent();
}
// Function to remove timeframes (input fields) for "Off" state
function removeTimeFrames(cell) {
    const timeInputs = cell.querySelectorAll('input[type="time"]');
    timeInputs.forEach(input => {
        input.value = ''; // Clear the time values
        input.style.display = 'none'; // Hide the time input fields
    });
}
// Function to add timeframes back (input fields) for "On" state
function addTimeFrames(cell) {
    const timeInputs = cell.querySelectorAll('input[type="time"]');
    timeInputs.forEach(input => {
        input.style.display = 'inline'; // Show the time input fields
    });
}
// Helper function to get formatted date for a day
function getFormattedDateForDay(dayIndex) {
    let weekStartDate = document.getElementById('weekStartDate')?.value;
    let date = weekStartDate ? new Date(weekStartDate) : new Date();
    
    if (isNaN(date)) {
        console.error("Invalid week start date.");
        return '';
    }

    const monday = getMonday(date);
    const weekDates = getWeekDates(monday);
    const dayMapping = {
        "monday": 0, "tuesday": 1, "wednesday": 2, "thursday": 3,
        "friday": 4, "saturday": 5, "sunday": 6
    };

    const validDayIndex = dayMapping[dayIndex.toLowerCase()];
    if (validDayIndex === undefined) return '';

    const currentDate = weekDates[validDayIndex];
    if (!(currentDate instanceof Date) || isNaN(currentDate.getTime())) return '';

    const formattedDate = formatDate(currentDate);
    const currentDayOfWeek = getDayOfWeek(currentDate);
    return `${formattedDate} (${currentDayOfWeek})`;
}
// Function to remove data for a specific day and employee from the database
function removeDayDataFromDB(name, lastName, fullDay) {
    // Prepare the data to send to the backend
    const requestData = {
        name,
        lastName,
        fullDay,
    };
    // Use fetch to send a DELETE request to the backend
    fetch('/rota/removeDayData', {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData),
    })
        .then(response => {
            if (response.ok) {
                return response.text();
            } else {
                throw new Error('Failed to remove data from the database.');
            }
        })
        .then(data => {
        })
        .catch(error => {
            console.error('Error removing data:', error);
        });
}
// Function to get the day of the week (e.g., "Monday", "Tuesday", etc.)
function getDayOfWeek(date) {
    const daysOfWeek = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    return daysOfWeek[date.getDay()];
}
// Function to Erase Data for the selected week
function clearAllRotaData() {
    // Clear UI time inputs
    document.querySelectorAll("#employeeRows input[type='time']").forEach(input => {
        input.value = '';
    });

    // Get the week start date (user-selected or current)
    let weekStartDate = document.getElementById('weekStartDate')?.value;
    let date = weekStartDate ? new Date(weekStartDate) : new Date();

    // Get Monday of the selected week
    const monday = getMonday(date);
    const weekDates = getWeekDates(monday); // You already have this function

    // Format dates as strings (same format used in DB e.g. 'dd/mm/yyyy (Day)')
    const formattedDays = weekDates.map(d => `${formatDate(d)} (${getDayOfWeek(d)})`);

    // Send request to backend to delete these days
    fetch('/rota/clearWeek', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ daysToDelete: formattedDays })
    })
    .then(response => response.text())
    .then(data => {
        console.log('Cleared from database:', data);
        alert('Rota cleared successfully for this week!');
    })
    .catch(error => {
        console.error('Error clearing rota:', error);
    });
}
// Window on Load funtions call
window.onload = () => {
    // Fetch employee data when the page loads
    fetchEmployeeData();
    // Display Curren Week
    displayCurrentWeek();
    // Call the loader when the page loads
    loadHolidayPercentage();
    // Call the loader when the page loads
    loadTaxPercentage();
    // Call the loader when the page loads
    loadPensionPercentage();
    // Call the function when needed, e.g., after updates
    calculateTotalCostWeek();
    // Function to fetch holidays from the database and color the cells in the rota table
    updateRotaWithHolidays();
};
</script>
</body>
</html>